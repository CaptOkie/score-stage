\documentclass[letterpaper,12pt]{article}

\usepackage[margin=1in]{geometry}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{enumerate}
\usepackage{setspace}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{graphicx}
\usepackage{float}

\colorlet{punct}{red!60!black}
\definecolor{background}{HTML}{EEEEEE}
\definecolor{delim}{RGB}{20,105,176}
\colorlet{numb}{magenta!60!black}

\lstdefinelanguage{json}{
    basicstyle=\footnotesize\ttfamily,
    showstringspaces=false,
    breaklines=true,
    frame=lines,
    backgroundcolor=\color{background},
    literate=
     *{0}{{{\color{numb}0}}}{1}
      {1}{{{\color{numb}1}}}{1}
      {2}{{{\color{numb}2}}}{1}
      {3}{{{\color{numb}3}}}{1}
      {4}{{{\color{numb}4}}}{1}
      {5}{{{\color{numb}5}}}{1}
      {6}{{{\color{numb}6}}}{1}
      {7}{{{\color{numb}7}}}{1}
      {8}{{{\color{numb}8}}}{1}
      {9}{{{\color{numb}9}}}{1}
      {:}{{{\color{punct}{:}}}}{1}
      {,}{{{\color{punct}{,}}}}{1}
      {\{}{{{\color{delim}{\{}}}}{1}
      {\}}{{{\color{delim}{\}}}}}{1}
      {[}{{{\color{delim}{[}}}}{1}
      {]}{{{\color{delim}{]}}}}{1},
}

\edef\restoreparindent{\parindent=\the\parindent\relax}
\usepackage[parfill]{parskip}
\restoreparindent

\title{
    \vfill
    {\Large SCHOOL} \\
    {\Large COURSE} \\[0.75em]
    {\Huge Score Stage} \\
}
\author{
    ME \\
    INSTRUCTOR
}

\begin{document}

\begin{titlepage}
    \maketitle
    \vfill
    \thispagestyle{empty}
\end{titlepage}

\tableofcontents
\listoffigures

\thispagestyle{empty}
\newpage

\spacing{1.3}

\section{Introduction}

Score Stage was inspired by a few different areas. The constant, rapid shift to everything being operated via the web,
the modern ability to reproduce complex software systems as a web alternative, and the ability for large groups of
people to collaborate instantly on open systems via web systems. Score Stage is the goal of bringing all these this to
task of music score writing.

First, with more systems moving towards web based platforms, music score writing should follow suit. This move brings
multiple advantages. such as, all of an individual's music scores are automatically backed up, the music scores are
available from any device with internet and a browser, and the user no longer has to install dedicated software on their
devices. With these advantages it will be easier for users to write, edit, and collaborate on music from anywhere and at
anytime.

Next, with the emergences of web systems such as Google Docs, these systems show what is possible with modern day web
technologies. Google Docs has managed to not only reproduce office suite software on a cloud platform, but it has
improved upon it by adding real-time collaboration. With systems such as Google Docs as examples of what is possible,
it is evident that a web based music writing system is possible.

Finally, websites such as Github have large groups of people collaborating on many open software systems. Score Stage
attempts to bring this style of collaboration to music score writing. Be it users attempting to write from ear what
someone else wrote, or original composers looking to share their creations, both can benefit from the highly
collaborative and open environment.

\section{Music Score Editor}

The first major hurdle that needs to be overcome to create a fully web based music score writing system, is the
in-browser music score editor. This editor has two base requirements that have to be met. First, the editor
needs to be a pure JavaScript Implementation (i.e. No browser plugins such as Flash or Java will be allowed to be used
to create the editor). Second, the editor, while simple at first, will need to be able to grow to rival native systems.

The editor must be a pure JavaScript implementation to allow for as much current and future support as possible. If
plugins were allowed users would need to make sure they have the correct plugin as well as a compatible browser.
This sort of issue is amplified by situations such as Apple not supporting Flash, and Chrome recently discontinuing
support for Java. With a pure JavaScript implementation current or future plugin supports are no longer a concern.

The editor will, in time, need to rival native music score editors. This is needed because for users to want to adopt
a web based system, they will need most, if not all, the features available in the native versions. Also, for users to
move their existing music scores to Score Stage they will need features for everything already used in their existing
music scores.

The ideal solution for the editor would be an existing open source editor. However, through extensive searching, there
appears to be very little in the ways of open source, web-based music notation rendering/writing implementations. The
most used, and basically only, open source JavaScript music notation library is called VexFlow. After studying what
VexFlow aims to accomplish, it is determined that VexFlow is almost entirely designed to only render music notation. Due
to this, the first thing that needs to be built is a JavaScript based music editor. The initial version only needs to be
complex enough such that a stable starting point can be created for the rest of the system.

The initial design used AngularJS and VexFlow, and started with doing just rendering. However, after working with
Angular and VexFlow, it soon became apparent that Angular would not be a good candidate to handle the data binding. The
issue with Angular was that VexFlow made custom DOM changes to render the music score because it creates an SVG.
Angular's ability to do proper data binding requires the developer to stay within the Angular digest cycle, which is the
system Angular uses to detect data changes. However, since VexFlow would go to the DOM on its own, these operations
would happen outside of Angular's digest cycle. Thus Angular was replaced with VueJS. Also, due to the complexity that
will be required for the editor, Webpack is used to allow JavaScript files to reference their own dependencies and build
a single JavaScript file that will be included in the HTML page.

\subsection{Data Model}

Before the editor can have user interaction, it must first be able to render the music score. Thus, the first task in
implementing the editor is to implement a rendering logic and the corresponding data model. Since the editor will be
written in JavaScript a JSON data model needs to be used. While the data model is initially designed for rendering, the
data model needs to allow for portions to be easily added, removed, and updated. A desired feature of the data model is
that the structure should force the data to be as valid as possible (i.e. it should be structured to not allow the data
to be in an invalid state).

To see the actual data model refer to Appendix A. A Tick is used to group notes into a chord, or in the case that a Tick
has no notes, it is treated as a rest; thus, as long as a Tick has a duration, it is valid. A Bar simply contains all
the ticks inside it. The Bar also contains the key signature and clef because it it legal for the clef and key signature
to change between bars, and different staffs can have different key signatures and clefs in the same Measure. Since the
Bars across all the staffs in a Measure must have the same time signature, it is stored in the Measure. The Measure also
stores all the Bars for all the staffs in order. Since a music score is technically 2-Dimensional, in that it has staffs
across the $ y $ and bars across the $ x $, only one of those parts can be structured to have no invalid state; thus,
since bars are more related vertically than horizontally, the bars in the same measure are grouped together and need the
same number needs to be in each measure. The Groups are the individual parts and define which staffs they cover. Groups
are ordered from the first to the last with respect to the order of the bars in each Measure. Each Group also defines
the number of staffs it covers. Since the bar count in Measures have to be kept in sync already, and groups are only
used to show which staff it covers at render time, the groups are moved into their own list.

\subsection{Rendering}

The desired rendered format for the music score is such that it looks like a sheet of music, thus measures will be
spread across rows. It is desirable to move as much of the rendering to VexFlow since it is built specifically to render
music scores. VexFlow, however, does not handle the actual layout of the music score. Thus determining the precise 
placement of each measure and bar will have to be manually calculated. 

The first task is rendering a single bar with its time signature, key signature, rests, and notes. To accomplish this
VexFlow has a Stave type which will render the lines for a bar, the key signature, the time signature, and the clef. To
render the rests and notes, VexFlow has the StaveNote, Beam, and Voice types. The StaveNote is an individual tick (i.e.
rest or chord), the Beam is the beam that connects groups of, for example, eighth notes, and the Voice is what groups a
list of StaveNotes together. Thus a Stave can be created, with the appropriate key signature, time signature, and clef.
A Voice can be created which contains all the StaveNotes, and VexFlow can automatically generate Beams for a list of
StaveNotes. VexFlow will also automatically apply the necessary modifiers to a note based on the key signature and
accidental of the note itself (e.g. if the key signature is sharp for a specific note and the note itself is sharp,
VexFlow will not render an accidental with the note). The only part left is to determine how wide to draw the Stave.
VexFlow does not assign a default width to Staves, but it can give a minimum width required to render a Voice. The
minimum width for the Voice is manually multiplied by a bar scale constant to add more space between ticks. VexFlow also
gives a padding for the beginning and end of the Stave, which is increased when a clef, time signature, or key signature
is added. Thus the padding plus the desired Voice width is added together to determine the width of a Stave.

The next task is to format a measure of bars. For a measure of bars to be formatted correctly, each bar must be the same
width, all the notes must be formatted to be placed correctly across all bars, and each bar must sit below the previous
bar. Each Stave has the dimensions $ x $, $ y $, $ width $, and $ height $, so this can be used to place bars in a
measure below the previous one. Also as long as they all get the same $ x $ and have the same $ width $, then each $ y $
can be set based on the previous Stave's $ y $ and $ height $ resulting in every bar being vertically and horizontally
aligned in the measure. VexFlow offers the ability to join voices together, in a Formatter; this allows the voices to be
formatted together so that they all line up when drawn. Since bars can have different key signatures and clefs, to get
an equal width for each bar, the max beginning and ending padding across all the bars need to be calculated and then
manually applied to each bar. Then the max width of all the voices needs to be calculated and each Voice needs to be
joined and then formatted using the largest voice's width. With the maximum paddings and max Voice width, a common width
can be applied to each Stave. Thus all the notes will now be aligned, and each Stave will be the same width.

Next, rows need to be created from all the measures. The first thing needed to do this is a maximum width for a row; the
exact value and how it is gathered will be covered later. Since we already have the current with of each measure, to
know when to start a new row with a measure is as simple as keeping track of the total width of the measures in the row
and if adding a new measure would make the total width greater than the max width of the row, a new row is started with
the current measure. If for some reason a single measure is wider than a row allows, that measure will still be its own
row. With all the rows calculated, the $ x $ value of each Stave in each measure to account for it new vertical
positioning. Since each row is now potentially only fractionally filled, the measures in each row needs to be rebalanced
to take up the entire maximum width of the row. To balance the row, the padding at the start and end of each Stave is
ignored, and only the width of the Voices in each measure is used to determine the ratio of space occupied by each
measure in the row. This allows Staves with the same notes, but different padding to have their Voices displayed
identically within the row. Each measure's ratio and the maximum row with is then used to calculate a new width for each
Stave and Voice in the measure such that the total with of all the measures is the same as the maximum width of the row.

Now that the whole score is roughly being rendered, it is time to add some details. These include excluding key
signatures, time signatures, and clefs unless it is the beginning of a row, or it is different to the previous bar or
measure. Also, if it is the last measure, then the ending bold double bar lines need to be added. Since each measure has a
reference to its previous measure, and while iterating the bars the index of the bar is know, it is a simple
matter of checking whether the previous measure or bar has a different time signature, key signature, or clef. When
creating a new row we already know if the measure will be the first in the row, so the time signature, key signature,
and clef can also be added then. Since each measure has a reference to the next measure, then if there is no next
measure the ending bold double bar line is added.

With the individual formatting complete for each bar, the group formatting needs to be added. This includes, adding
the actual Groups at the beginning of each measure to show which Group each staff belongs to, and adding bar lines
across the entire measure for special bar lines. To add the groups at the beginning of each row, a padding in front of
each measure needs to be added to allow space for writing the Group abbreviation. This padding will simply be created by
setting the $ x $ of the Staves in the first measure of each row to the padding value, and subtracting the padding
value from the true max width to get the implemented max width for each row. With the space at the beginning of each
row VexFlow's StaveConnector type can be used to draw a bar lines across Staves in each measure. If it is the first
measure in the row, then a single line StaveConnector is drawn at the beginning of the measure across all the Staves.
Then for each group a single line StaveConnector is drawn at the beginning and end across all the staffs belonging to
the group; however, if it is the final measure, then the ending StaveConnector is replaced by a bold double bar line or
if it is the first measure in the row, the beginning StaveConnector is replaced by a double bar line with the group's
abbreviation as text. These group StaveConnectors help show which staffs belong to the same group throughout the entire
row.

\subsection{User Interaction}

With the ability to render the full score, the user interaction needs to be added. It is assumed that a starting music
score will have one bar and one group, allowing more to be added from there. Since all interaction in the music score
relates to a specific location, the first part is adding a cursor and allowing the cursor to be moved. Next, key
signatures, time signatures, and clefs need to be able to be set in their respective part. Then measures and staffs need
to be added and deleted. Finally, notes and rests need to be added and deleted. With these parts, a basic music score
editor will be functional.

Even though VexFlow uses and SVG to render the entire music score, due to how the staffs are rendered, simple JavaScript
events cannot be properly bound to the elements. If VexFlow surrounded different sections of the SVG into groups, then
it may have been possible to use normal event handlers. Due to this limitation to find the location for a cursor, the
$ x $ and $ y $ coordinates of the user's click needs to be read and then compared against, first the $ y $ of the row
to determine the clicked row, then the $ x $ of the measures in the row to determine the clicked measure, and finally
the $ y $ of the Stave to determine the clicked bar. With the proper bar located, the Stave and Voice can now be used to
find the location in the bar that was clicked.

First the $ x $ coordinate of the click is checked against the Tickables in the Voice. To determine if it was note
or rest that was selected or if it was a space between the notes that was selected, a percentage based cutoff is used.
The cutoff depends on the distance between either the start of the bar and the head of the first note, the end of one
note and the start of the next note, or the end of the last note and the end of the bar. See Figure
\ref{fig:hori-cutoff} for the exact horizontal cut off areas. If the $ x $ coordinate is in a space that does not border
a note, as seen in Figure \ref{fig:hori-cutoff}, then the cursor is placed in the space in the matching space, otherwise
the cursor is placed on the nearest note.

\begin{figure}[H]
    \begin{center}
        \includegraphics[scale=0.2]{imgs/hori-cutoff.png}
    \end{center}
    \caption{Horizontal Cutoff Zones}
    \label{fig:hori-cutoff}
\end{figure}

Next, to determine the bar line that was clicked, the $ y $ coordinate is compared against all the lines in the bar to
find the nearest line. A similar ratio based system as used with the $ x $ coordinate is used to determine if the cursor
should be placed between two lines or directly on a line. If the $ y $ coordinate is within the \textit{Space Zone} as
seen in Figure \ref{fig:vert-cutoff} then the cursor will be placed in the space between the two lines, but if the $ y $
coordinate is within the \textit{Line Zone} as seen in Figure \ref{fig:vert-cutoff} then the cursor will be placed on
the line within the zone. The line zones have to extend partially into the spaces between the lines because a line
itself is not tall enough to allow it to be clicked easily. These zones are implicit for spaces and lines above and
below the visible lines in the bar.

\begin{figure}[H]
    \begin{center}
        \includegraphics[scale=0.2]{imgs/vert-cutoff.png}
    \end{center}
    \caption{Vertical Cutoff Zones}
    \label{fig:vert-cutoff}
\end{figure}

With a cursor that stores the exact location of a click, more complex user interaction can be implemented.

\section{Conclusion}

\subsection{Results}

\subsection{Future}

\newpage

\section{Appendices}

\subsection{Appendix A -- Data Model}

\begin{lstlisting}[language=json, caption=Note]
{
    "letter" : <String>,
    "octave" : <Number>,
    "accidental" : <String>
}
\end{lstlisting}

\begin{lstlisting}[language=json, caption=Tick]
{
    "duration" : <Number>,
    "notes" : [ <Note> ]
}
\end{lstlisting}

\begin{lstlisting}[language=json, caption=Bar]
{
    "clef" : <String>,
    "keySig" : <String>,
    "ticks" : [ <Tick> ]
}
\end{lstlisting}

\begin{lstlisting}[language=json, caption=TimeSignature]
{
    "upper" : <Number>,
    "lower" : <Number>
}
\end{lstlisting}

\begin{lstlisting}[language=json, caption=Measure]
{
    "timeSig" : <TimeSignature>,
    "bars" : [ <Bar> ],
    "id" : <String>,
    "prev" : <Measure>,
    "next" : <Measure>
}
\end{lstlisting}

\begin{lstlisting}[language=json, caption=Group]
{
    "name" : <String>,
    "abbr" : <String>,
    "count" : <Number>
}
\end{lstlisting}

\begin{lstlisting}[language=json, caption=MusicScore]
{
    "id" : <String>,
    "title" : <String>,
    "measures" : [ <Measure> ],
    "groups" : [ <Group> ],
    "rev" : <String>
}
\end{lstlisting}


\end{document}
